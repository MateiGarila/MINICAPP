Index: app/src/main/java/com/example/mini_cap/view/SessionActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.mini_cap.view;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\n\r\nimport android.annotation.SuppressLint;\r\nimport android.app.AlarmManager;\r\nimport android.app.Notification;\r\nimport android.app.NotificationChannel;\r\nimport android.app.NotificationManager;\r\nimport android.app.PendingIntent;\r\nimport android.content.BroadcastReceiver;\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.content.IntentFilter;\r\nimport android.os.Build;\r\nimport android.os.Bundle;\r\nimport android.os.CountDownTimer;\r\nimport android.util.Log;\r\nimport android.view.View;\r\nimport android.widget.Button;\r\nimport android.widget.EditText;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\n\r\nimport com.example.mini_cap.R;\r\nimport com.example.mini_cap.controller.DBHelper;\r\nimport com.example.mini_cap.model.Day;\r\nimport com.example.mini_cap.model.Preset;\r\n\r\nimport java.util.Calendar;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\nimport java.util.TimeZone;\r\n\r\npublic class SessionActivity extends AppCompatActivity  {\r\n    private EditText userInputEditText; // to simulate notification\r\n    private Button NotificationButton;// to simulate notification\r\n\r\n    //Declaration of all UI elements\r\n    protected TextView mainTextView, statusTextView, notificationTierTextView,\r\n            timeRemainingTextView, timerTextView;\r\n    protected Button startPauseBTN, addPresetBTN, editPresetBTN, endSessionBTN;\r\n\r\n    //Needed\r\n    private final static String TAG = \"SessionActivity\";\r\n    private final boolean isCreate = true;\r\n    private static final String NOTIFICATION_CHANNEL_ID = \"UV_INDEX_NOTIFICATION_CHANNEL\";\r\n    private static final int NOTIFICATION_ID = 1;\r\n    private static final int MAX_TIER = 5;\r\n\r\n    //Countdown timer variables\r\n    //For Testing purposes. This is 10 seconds\r\n    private static final long START_TIME_IN_MILLIS = 10000;\r\n    private static final long DEFAULT_TIMER_IN_MILLIS = 1050000;\r\n    private static long calculatedTimer;\r\n    private CountDownTimer countDownTimer;\r\n    private long timeLeftInMillis;\r\n    private int notificationTier;\r\n    private boolean isSessionStarted;\r\n    private boolean isSessionPaused;\r\n\r\n    private final BroadcastReceiver uvNotificationReceiver = new BroadcastReceiver() {\r\n        @Override\r\n        public void onReceive(Context context, Intent intent) {\r\n            int uvIndex = intent.getIntExtra(\"uvIndex\", 1);\r\n            showUVNotification(uvIndex);\r\n        }\r\n    };\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_session);\r\n\r\n        //Attaching the UI elements to their respective objects\r\n        //TextViews\r\n        mainTextView = findViewById(R.id.sessionActivityTextView);\r\n        statusTextView = findViewById(R.id.sessionStatusTextView);\r\n        notificationTierTextView = findViewById(R.id.notificationTierTV);\r\n        timeRemainingTextView = findViewById(R.id.timeRemainingTV);\r\n        timerTextView = findViewById(R.id.countdown);\r\n\r\n        //Buttons\r\n        startPauseBTN = findViewById(R.id.startPauseSessionBTN);\r\n        addPresetBTN = findViewById(R.id.addPresetBTN);\r\n        editPresetBTN = findViewById(R.id.editUserBTN);\r\n        endSessionBTN = findViewById(R.id.endSessionBTN);\r\n\r\n        // notification\r\n        userInputEditText = findViewById(R.id.user_input_edit_text);\r\n        NotificationButton = findViewById(R.id.SendNotification);\r\n\r\n        //Tier 0 is the default tier of the notification\r\n        notificationTier = 0;\r\n        isSessionStarted = false;\r\n        isSessionPaused = false;\r\n\r\n        //Make end session button invisible when no session is started\r\n        endSessionBTN.setVisibility(View.INVISIBLE);\r\n\r\n        mainTextView.setOnClickListener(v -> finish());\r\n\r\n        addPresetBTN.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                Log.d(TAG, \"Add Preset PRESSED\");\r\n                PresetFragment fragment = PresetFragment.newInstance(null, isCreate);\r\n                fragment.show(getSupportFragmentManager(), \"CreatePreset\");\r\n\r\n            }\r\n        });\r\n\r\n        editPresetBTN.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                Intent intent = new Intent(getBaseContext(), EditActivity.class);\r\n                startActivity(intent);\r\n            }\r\n        });\r\n\r\n        startPauseBTN.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n\r\n                if(isSessionStarted){\r\n                    //Here handle what happens when the session is paused\r\n                    if(isSessionPaused){\r\n                        //if session is paused, then un-pause it\r\n                        continueSession();\r\n                    }else{\r\n                        //else pause session\r\n                        pauseSession();\r\n                    }\r\n\r\n                }else{\r\n                    //Session not started need to select Preset first\r\n                    StartSessionFragment fragment = new StartSessionFragment();\r\n                    fragment.show(getSupportFragmentManager(), \"StartSession\");\r\n                }\r\n\r\n            }\r\n        });\r\n\r\n        endSessionBTN.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n\r\n                //here handle what happens when a session ends\r\n                endSession();\r\n\r\n            }\r\n        });\r\n\r\n        NotificationButton.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                String userInput = userInputEditText.getText().toString();\r\n                if (isValidInput(userInput)) {\r\n                    int uvIndex = Integer.parseInt(userInput);\r\n                    showUVNotification(uvIndex);\r\n                } else {\r\n                    // Handle invalid input, e.g., show a toast\r\n                }\r\n            }\r\n        });\r\n\r\n        createNotificationChannel();\r\n\r\n        // Register the broadcast receiver\r\n        IntentFilter filter = new IntentFilter(\"UV_NOTIFICATION_ACTION\");\r\n        registerReceiver(uvNotificationReceiver, filter);\r\n\r\n        // Schedule repeated notifications every 2 hours\r\n        scheduleRepeatingNotifications();\r\n    }\r\n\r\n    @Override\r\n    protected void onDestroy() {\r\n        // Unregister the broadcast receiver to avoid memory leaks\r\n        unregisterReceiver(uvNotificationReceiver);\r\n        super.onDestroy();\r\n    }\r\n\r\n    private boolean isValidInput(String input) {\r\n        try {\r\n            int number = Integer.parseInt(input);\r\n            return number >= 1;\r\n        } catch (NumberFormatException e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private void createNotificationChannel() {\r\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\r\n            String channelName = \"UV Index Notifications\";\r\n            int importance = NotificationManager.IMPORTANCE_DEFAULT;\r\n            NotificationChannel channel = new NotificationChannel(NOTIFICATION_CHANNEL_ID, channelName, importance);\r\n            NotificationManager notificationManager = getSystemService(NotificationManager.class);\r\n            if (notificationManager != null) {\r\n                notificationManager.createNotificationChannel(channel);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void showUVNotification(int uvIndex) {\r\n        String notificationMessage;\r\n\r\n        if(uvIndex <= 2){\r\n            notificationMessage = \"Low risk of UV exposure, don't forget to wear sunscreen.\";\r\n\r\n        } else if(uvIndex <= 5) {\r\n            notificationMessage = \"Moderate risk of UV exposure. Please wear sunscreen.\";\r\n\r\n        } else if(uvIndex <= 7) {\r\n            notificationMessage = \"High risk of skin damage. Wear sunscreen and seek shade.\";\r\n\r\n        } else if(uvIndex <= 10) {\r\n            notificationMessage = \"Very High Risk! Wear sunscreen, seek shade or stay indoors.\";\r\n        } else {\r\n            notificationMessage = \"Extreme Risk! Stay indoors. If not possible then wear protective clothing, sunscreen and sunglasses, and seek shade.\";\r\n        }\r\n\r\n        Notification notification = createNotification(notificationMessage);\r\n        NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);\r\n\r\n        if (notificationManager != null) {\r\n            notificationManager.notify(NOTIFICATION_ID, notification);\r\n        }\r\n    }\r\n\r\n    private Notification createNotification(String contentText) {\r\n        Intent notificationIntent = new Intent(this, SessionActivity.class);\r\n        PendingIntent pendingIntent = PendingIntent.getActivity(\r\n                this,\r\n                NOTIFICATION_ID,\r\n                notificationIntent,\r\n                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE\r\n        );\r\n\r\n        return new Notification.Builder(this, NOTIFICATION_CHANNEL_ID)\r\n                .setContentTitle(\"UV Index Alert\")\r\n                .setContentText(contentText)\r\n                .setSmallIcon(R.mipmap.ic_launcher) // Set an appropriate app icon here\r\n                .setContentIntent(pendingIntent)\r\n                .setAutoCancel(true)\r\n                .build();\r\n    }\r\n\r\n    private void scheduleRepeatingNotifications() {\r\n        AlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);\r\n        Intent notificationIntent = new Intent(this, UVNotificationReceiver.class);\r\n        PendingIntent pendingIntent = PendingIntent.getBroadcast(\r\n                this,\r\n                NOTIFICATION_ID,\r\n                notificationIntent,\r\n                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE\r\n        );\r\n\r\n        // Schedule repeating notifications every 2 hours\r\n        // can be modify for the demo for 5000 milliseconds\r\n        long repeatInterval = 2 * 60 * 60 * 1000; // 2 hours in milliseconds,\r\n        if (alarmManager != null) {\r\n            alarmManager.setRepeating(\r\n                    AlarmManager.RTC_WAKEUP,\r\n                    System.currentTimeMillis() + repeatInterval,\r\n                    repeatInterval,\r\n                    pendingIntent\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This is the method which receives the selected preset to start the session, which then calls\r\n     * the startSession() method; starting the session\r\n     * @param preset the selected preset\r\n     */\r\n    public void fetchPresetStartSession(Preset preset){\r\n\r\n        //Toast.makeText(this, \"I got called from fragment: \" + preset.getName(), Toast.LENGTH_SHORT).show();\r\n        startSession(preset);\r\n    }\r\n\r\n    /**\r\n     * This method handles what happens at the start of a session\r\n     * @param preset that has been selected for the session\r\n     */\r\n    @SuppressLint(\"SetTextI18n\")\r\n    private void startSession(Preset preset){\r\n\r\n        //Toast.makeText(this, \"Session Started\", Toast.LENGTH_SHORT).show();\r\n\r\n        //First update UI\r\n        statusTextView.setText(\"Current session with preset: \" + preset.getName());\r\n        updateTier();\r\n        startPauseBTN.setText(R.string.pause_session_text);\r\n        endSessionBTN.setVisibility(View.VISIBLE);\r\n\r\n        //Second update variables\r\n        isSessionStarted = true;\r\n\r\n        //Third purpose of method\r\n        //For demo purposes (timer will be set to 10 seconds)\r\n        timeLeftInMillis = DEFAULT_TIMER_IN_MILLIS;\r\n        //calculatedTimer = timerDurationAlgo(ageParameter(preset.getAge()),\r\n        //        skinToneParameter(preset.getSkinTone()), uvParameter());\r\n        //timeLeftInMillis = calculatedTimer;\r\n\r\n        countDownManager();\r\n\r\n    }\r\n\r\n    /**\r\n     * This method handles what happens when a session is paused\r\n     */\r\n    private void pauseSession(){\r\n\r\n        //Toast.makeText(this, \"Session Paused\", Toast.LENGTH_SHORT).show();\r\n\r\n        //First update UI\r\n        startPauseBTN.setText(R.string.continue_session_text);\r\n\r\n        //Second update variables\r\n        isSessionPaused = true;\r\n\r\n        //Third purpose of method\r\n        countDownTimer.cancel();\r\n\r\n    }\r\n\r\n    /**\r\n     * This method handles what happens when a session is continued\r\n     */\r\n    private void continueSession(){\r\n\r\n        //Toast.makeText(this, \"Session Continued\", Toast.LENGTH_SHORT).show();\r\n\r\n        //First update UI\r\n        startPauseBTN.setText(R.string.pause_session_text);\r\n\r\n        //Second update variables\r\n        isSessionPaused = false;\r\n\r\n        //Third purpose of method\r\n        countDownManager();\r\n\r\n    }\r\n\r\n    /**\r\n     * This method handles what happens when a session ends\r\n     */\r\n    private void endSession(){\r\n\r\n        //First update UI\r\n        endSessionBTN.setVisibility(View.INVISIBLE);\r\n        startPauseBTN.setText(R.string.start_session_text);\r\n        statusTextView.setText(R.string.session_status_not_started);\r\n        notificationTierTextView.setText(R.string.notification_tier);\r\n\r\n        //Second update variables\r\n        isSessionStarted = false;\r\n        isSessionPaused = false;\r\n        notificationTier = 0;\r\n\r\n        //Third purpose of method\r\n        countDownTimer.cancel();\r\n        timerTextView.setText(R.string.default_clock);\r\n    }\r\n\r\n    /**\r\n     * This method handles the display timer on SessionActivity\r\n     */\r\n    private void updateCountDownText(){\r\n\r\n        int minutes = (int) (timeLeftInMillis / 1000) / 60;\r\n        int seconds = (int) (timeLeftInMillis / 1000) % 60;\r\n\r\n        String timeLeftFormatted = String.format(Locale.getDefault(), \"%02d:%02d\", minutes,\r\n                seconds);\r\n\r\n        timerTextView.setText(timeLeftFormatted);\r\n    }\r\n\r\n    /**\r\n     * This method handles notification tiers. Depending on the tier a different text is applied to\r\n     * the notification\r\n     */\r\n    @SuppressLint(\"SetTextI18n\")\r\n    private void updateTier(){\r\n\r\n        notificationTier = notificationTier + 1;\r\n\r\n        if(notificationTier > MAX_TIER){\r\n            notificationTier = 1;\r\n        }\r\n\r\n        notificationTierTextView.setText(\"Current notification tier: \" + notificationTier);\r\n\r\n    }\r\n\r\n    /**\r\n     * This method manages the countdown. Since there is no countDownTimer.pause() each time the\r\n     * timer is paused it needs to be reset at the timeLeftInMillis\r\n     */\r\n    private void countDownManager(){\r\n\r\n        countDownTimer = new CountDownTimer(timeLeftInMillis, 1000) {\r\n            @Override\r\n            public void onTick(long millisUntilFinished) {\r\n                timeLeftInMillis = millisUntilFinished;\r\n                updateCountDownText();\r\n            }\r\n\r\n            @Override\r\n            public void onFinish() {\r\n\r\n                String notificationMessage = notificationMessage(notificationTier);\r\n                Toast.makeText(getBaseContext(), notificationMessage, Toast.LENGTH_SHORT).show();\r\n                //Notifications go here\r\n                //-->\r\n                \r\n                //timeLeftInMillis = calculatedTimer;\r\n                //this is the demo mode\r\n                timeLeftInMillis = DEFAULT_TIMER_IN_MILLIS;\r\n                countDownManager();\r\n            }\r\n\r\n        }.start();\r\n\r\n    }\r\n\r\n    /**\r\n     * Based on the notification tier this method returns the message that will be displayed in the\r\n     * notification\r\n     * @param notificationTier the current tier of notification (how many times the timer has\r\n     *                         completed it's run\r\n     * @return the string to be displayed in the notification\r\n     */\r\n    private String notificationMessage(int notificationTier){\r\n\r\n        String message = \"\";\r\n\r\n        switch (notificationTier){\r\n\r\n            case 1:\r\n                message = \"Timer complete! Please hydrate yourself.\";\r\n                break;\r\n            case 2:\r\n                message = \"Timer complete! Please apply sunscreen (re-apply every 2 hours)\";\r\n                break;\r\n            case 3:\r\n                message = \"Timer complete! Please hydrate yourself\";\r\n                break;\r\n            case 4:\r\n                message = \"Timer complete! Please take shelter from the sun for a timer's duration\";\r\n                break;\r\n            case 5:\r\n                message = \"Timer complete! Enjoy the sun!\";\r\n                break;\r\n            default:\r\n                Toast.makeText(this, \"An error has happened in notificationMessage\",\r\n                        Toast.LENGTH_SHORT).show();\r\n                break;\r\n        }\r\n\r\n        updateTier();\r\n\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Based on the selected preset, the age will be used in the algorithm to determine the timer\r\n     * for that preset\r\n     * @param age the age from the preset\r\n     * @return age parameter to be used in the algorithm\r\n     */\r\n    private double ageParameter(int age){\r\n\r\n        double ageParam = 0.0;\r\n\r\n        if(age < 13){\r\n            ageParam = -2.0;\r\n        }else if(age < 16){\r\n            ageParam = -1.5;\r\n        }else if(age < 19){\r\n            ageParam = -1.0;\r\n        }else if(age < 22){\r\n            ageParam = -0.5;\r\n        }else if(age < 25){\r\n            ageParam = 0;\r\n        }else if(age < 28){\r\n            ageParam = 0.5;\r\n        }else if(age < 59){\r\n            ageParam = 1.0;\r\n        }else if(age < 62){\r\n            ageParam = 0.5;\r\n        }else if(age < 65){\r\n            ageParam = 0.0;\r\n        }else if(age < 68){\r\n            ageParam = -0.5;\r\n        }else if(age < 71){\r\n            ageParam = -1.0;\r\n        }else if(age < 74){\r\n            ageParam = -1.5;\r\n        }else{\r\n            ageParam = -2.0;\r\n        }\r\n\r\n        return ageParam;\r\n    }\r\n\r\n    /**\r\n     * This method calculates the parameter obtained from the preset's skin tone\r\n     * @param skinTone The skin tone of the preset\r\n     * @return parameter used to calculate the timer\r\n     */\r\n    private double skinToneParameter(String skinTone){\r\n\r\n        double skinParam = 0.0;\r\n\r\n        if(skinTone.equalsIgnoreCase(\"Light, pale white\")){\r\n            skinParam = -2.0;\r\n        }else if(skinTone.equalsIgnoreCase(\"White, fair\")){\r\n            skinParam = -1.5;\r\n        }else if(skinTone.equalsIgnoreCase(\"Medium white to light brown\")){\r\n            skinParam = -1.0;\r\n        }else if(skinTone.equalsIgnoreCase(\"Olive, moderate brown\")){\r\n            skinParam = -0.5;\r\n        }else if(skinTone.equalsIgnoreCase(\"Brown, dark brown\")){\r\n            skinParam = 0.0;\r\n        }else if(skinTone.equalsIgnoreCase(\"Very dark brown to black\")){\r\n            skinParam = 1.0;\r\n        }else {\r\n            skinParam = 0.0;\r\n        }\r\n\r\n        return skinParam;\r\n    }\r\n\r\n    /**\r\n     * This method calculates the parameter obtained from the average UV index over a minute\r\n     * @return the multiplier parameter used in the timer algorithm\r\n     */\r\n    private double uvParameter(){\r\n\r\n        DBHelper dbHelper = DBHelper.get(this);\r\n        Date currentDate = new Date();\r\n        Calendar calendar = Calendar.getInstance();\r\n        TimeZone timeZone = calendar.getTimeZone();\r\n\r\n        int hours = calendar.get(Calendar.HOUR_OF_DAY);\r\n        int minutes = calendar.get(Calendar.MINUTE);\r\n\r\n        int avgUVIndex = (int) dbHelper.getMinuteAvg(new Day(currentDate), minutes, hours, false);\r\n        double uvParam = 0.0;\r\n\r\n        if(avgUVIndex == 0){\r\n            return 1;\r\n        }else if(avgUVIndex < 2){\r\n            uvParam = 0.5;\r\n        } else if(avgUVIndex < 4){\r\n            uvParam = 0.75;\r\n        }else if(avgUVIndex < 6){\r\n            uvParam = 1.0;\r\n        } else if(avgUVIndex < 8){\r\n            uvParam = 1.5;\r\n        }else if(avgUVIndex < 10){\r\n            uvParam = 1.75;\r\n        } else if(avgUVIndex < 12){\r\n            uvParam = 2.0;\r\n        }\r\n\r\n        return uvParam;\r\n    }\r\n\r\n    /**\r\n     * This method determines the duration of the timer based off 3 parameters\r\n     * @param age parameter, obtained from the preset\r\n     * @param skin parameter, obtained from the preset\r\n     * @param uvIndex parameter, obtained from the minute average\r\n     * @return timer duration\r\n     */\r\n    public long timerDurationAlgo(double age, double skin, double uvIndex){\r\n\r\n        long time = 0;\r\n        double presetParam = age + skin;\r\n\r\n        if(presetParam == 0.0){\r\n            return DEFAULT_TIMER_IN_MILLIS;\r\n        }\r\n\r\n        double timerSelector = presetParam * uvIndex;\r\n\r\n        if(timerSelector <= -6){\r\n            //this is 15 minutes\r\n            time = 900000;\r\n        }else if(timerSelector <= -4){\r\n            //this is 16 minutes\r\n            time = 960000;\r\n        }else if(timerSelector <= -2){\r\n            //this is 17 minutes\r\n            time = 1020000;\r\n        }else if(timerSelector <= 0){\r\n            //this is 17 minutes 30 seconds\r\n            time = DEFAULT_TIMER_IN_MILLIS;\r\n        }else if(timerSelector <= 2){\r\n            //this is 18 minutes\r\n            time = 1080000;\r\n        }else{\r\n            //this is 19 minutes\r\n            time = 1140000;\r\n        }\r\n\r\n        return time;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/mini_cap/view/SessionActivity.java b/app/src/main/java/com/example/mini_cap/view/SessionActivity.java
--- a/app/src/main/java/com/example/mini_cap/view/SessionActivity.java	(revision 714fae3248a21e0a8c2528fde4a29c9ed8a9e2c9)
+++ b/app/src/main/java/com/example/mini_cap/view/SessionActivity.java	(date 1691432727547)
@@ -54,7 +54,7 @@
     private static final long DEFAULT_TIMER_IN_MILLIS = 1050000;
     private static long calculatedTimer;
     private CountDownTimer countDownTimer;
-    private long timeLeftInMillis;
+    private long timeLeftInMillis = START_TIME_IN_MILLIS;
     private int notificationTier;
     private boolean isSessionStarted;
     private boolean isSessionPaused;
@@ -300,7 +300,7 @@
 
         //Third purpose of method
         //For demo purposes (timer will be set to 10 seconds)
-        timeLeftInMillis = DEFAULT_TIMER_IN_MILLIS;
+        timeLeftInMillis = START_TIME_IN_MILLIS;
         //calculatedTimer = timerDurationAlgo(ageParameter(preset.getAge()),
         //        skinToneParameter(preset.getSkinTone()), uvParameter());
         //timeLeftInMillis = calculatedTimer;
@@ -420,7 +420,7 @@
                 
                 //timeLeftInMillis = calculatedTimer;
                 //this is the demo mode
-                timeLeftInMillis = DEFAULT_TIMER_IN_MILLIS;
+                timeLeftInMillis = START_TIME_IN_MILLIS;
                 countDownManager();
             }
 
